#lang racket

(provide query/rows
         query
         from
         where
         select
         join
         limit
         distinct
         aggregate
         count
         order-by
         extend)

(require racket/list
         racket/stream
         racket/set
         racket/dict)

(struct query-result (data)
  #:transparent)
;; data : (Streamof (Hashof Symbol Any))

;; -----------------------------------------------------------------------------
;; 1) query/rows and query
;; -----------------------------------------------------------------------------

(define (query/rows initial-qresult . clauses)
  (stream->list
   (query-result-data
    (apply query initial-qresult clauses))))

(define (query initial-qresult . clauses)
  (foldl (lambda (clause current-qresult)
           (clause current-qresult))
         initial-qresult
         clauses))

;; -----------------------------------------------------------------------------
;; 2) from
;; -----------------------------------------------------------------------------

(define (from table #:qualify [prefix #f])
  (define s
    (if prefix
        (for/stream ([row table])
          (prefix-keys row prefix))
        (for/stream ([row table])
          row)))
  (query-result s))

(define (prefix-keys row prefix)
  (for/hash ([(k v) (in-hash row)])
    (values (string->symbol (format "~a.~a"
                                    (symbol->string prefix)
                                    (symbol->string k)))
            v)))

;; -----------------------------------------------------------------------------
;; 3) where
;; -----------------------------------------------------------------------------

(define (where keep?)
  (lambda (qr)
    (query-result
     (stream-filter keep?
                    (query-result-data qr)))))

;; -----------------------------------------------------------------------------
;; 4) select
;; -----------------------------------------------------------------------------
;; Use #:when in for/hash so that we never produce 0 or 1 value
;; when the column doesn't match.

(define (select . col-names)
  (lambda (qr)
    (query-result
     (stream-map
      (lambda (row)
        ;; Check if all requested columns exist
        (for ([c (in-list col-names)])
          (unless (hash-has-key? row c)
            (error 'select
                   (format "Missing column ~a in row: ~v" c row))))
        ;; Keep only these columns
        (for/hash ([(k v) (in-hash row)]
                   #:when (memq k col-names))
          (values k v)))
      (query-result-data qr)))))

;; -----------------------------------------------------------------------------
;; Helpers: hash-union, list->stream
;; -----------------------------------------------------------------------------

(define (hash-union h1 h2)
  (define new-hash (hash-copy h1))
  (for ([(k v) (in-hash h2)])
    (hash-set! new-hash k v))
  new-hash)

(define (list->stream lst)
  (for/stream ([x (in-list lst)])
    x))

;; -----------------------------------------------------------------------------
;; 5) join
;; -----------------------------------------------------------------------------

(define (join qr2 col1 col2)
  (lambda (qr1)
    (define s1 (query-result-data qr1))
    (define s2 (stream->list (query-result-data qr2))) ; force entire right side

    (define first1 (stream-first s1 (void)))
    (define rest1  (stream-rest s1))

    ;; If both sides have data, check for column conflicts
    (when (and (not (void? first1))
               (not (null? s2)))
      (define cols1 (hash-keys first1))
      (define cols2 (hash-keys (first s2)))
      (define conflicts (set-intersect (set cols1) (set cols2)))
      (unless (set-empty? conflicts)
        (error 'join
               (format "Conflicting columns: ~v"
                       (set->list conflicts)))))


    ;; Nested-loop join
    (define (join-rows row1)
      (define val1 (hash-ref row1 col1))
      (for/list ([row2 s2]
                 #:when (equal? val1 (hash-ref row2 col2)))
        (hash-union row1 row2)))

    (define final-stream
      (stream-append
       (if (void? first1)
           (list->stream '())        ; empty stream if s1 is empty
           (list->stream (join-rows first1)))
       (for/stream ([r (in-stream rest1)])
         (for*/stream ([r2 (in-list (join-rows r))])
           r2))))

    (query-result final-stream)))

;; -----------------------------------------------------------------------------
;; 6) limit
;; -----------------------------------------------------------------------------

(define (limit n)
  (lambda (qr)
    (query-result
     (stream-take (query-result-data qr)
                  n))))

;; -----------------------------------------------------------------------------
;; 7) distinct
;; -----------------------------------------------------------------------------

(define (distinct)
  (lambda (qr)
    (define s (query-result-data qr))
    (define seen (make-hash))

    (define (distinct-helper st)
      (stream-lazy
       (cond
         [(stream-empty? st)
          (list->stream '())] ; produce empty stream
         [else
          (define r (stream-first st))
          (if (hash-has-key? seen r)
              (distinct-helper (stream-rest st))
              (begin
                (hash-set! seen r #t)
                (stream-cons r
                             (distinct-helper (stream-rest st)))))])))

    (query-result (distinct-helper s))))

;; -----------------------------------------------------------------------------
;; 8) aggregate
;; -----------------------------------------------------------------------------

(define (aggregate col-name #:using aggregator #:by by-col)
  (lambda (qr)
    (define s (query-result-data qr))
    (define row-list (stream->list s))
    (when (and (pair? row-list))
      (unless (hash-has-key? (first row-list) col-name)
        (error 'aggregate (format "Missing column ~a" col-name)))
      (unless (hash-has-key? (first row-list) by-col)
        (error 'aggregate (format "Missing column ~a" by-col))))

    ;; Group rows by `by-col`
    (define groups (make-hash))
    (for ([r (in-list row-list)])
      (define key (hash-ref r by-col))
      (define val (hash-ref r col-name))
      (hash-update! groups key (lambda (old) (cons val old)) '()))

    ;; Build final aggregated rows: two columns
    (define aggregated
      (for/list ([(gk vals) (in-hash groups)])
        (hash by-col  gk
              col-name (apply aggregator vals))))

    (query-result (list->stream aggregated))))

;; -----------------------------------------------------------------------------
;; 9) count aggregator
;; -----------------------------------------------------------------------------

(define (count . vals)
  (length vals))

;; -----------------------------------------------------------------------------
;; 3.2 Additional Features
;; -----------------------------------------------------------------------------

(define (order-by col #:compare [cmp <])
  (lambda (qr)
    (define row-list (stream->list (query-result-data qr)))
    (define sorted-list
      (sort row-list
            (lambda (r1 r2)
              (cmp (hash-ref r1 col)
                   (hash-ref r2 col)))))
    (query-result (list->stream sorted-list))))

(define (extend new-col-name f)
  (lambda (qr)
    (define s (query-result-data qr))
    (define extended-stream
      (stream-map
       (lambda (row)
         (hash-set row new-col-name (f row)))
       s))
    (query-result extended-stream)))


